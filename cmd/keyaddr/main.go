package main

//go:generate gopherjs build --minify

// This system generates js code from go source
// so that we can have a single-source solution for keys, addresses, and signatures.
// Use "go generate" to build this.

// object API --
//  WordsFromBytes(lang:string, bytes:string) : string -- converts the bytes to a space-separated list of mnemonic words in the specified language
//  BytesFromWords(lang:string, words string) : string -- converts a space-separated list of words in lang back to a set of bytes
//  NewPrivateMaster(seed:string) : key -- creates and returns a new private master key using the given seed.
//  NewKey(string) : key -- creates a key from its text representation (if it was valid)
//  NewAddress(string) : address -- creates an address object from the string representing it (if valid)
//  key.Public() : key -- returns a public key that cannot be used for signing but may be used to generate child public keys.
//  key.Child(index) : key -- returns a child key at the given index; if the parent was private, so is the child.
//  key.HardenedChild(index) : key -- creates a child public key at the index that cannot be used to generate more children.
//  key.Sign(message) : signature -- signs a message and returns a signature
//  signature.Verify(message, key) : bool
//  key.Address() : address -- generates an address from a public key

import (
	"encoding/hex"
	"errors"

	"github.com/btcsuite/btcd/btcec"

	"github.com/oneiro-ndev/ndaumath/pkg/b32"

	"github.com/gopherjs/gopherjs/js"
	"github.com/miratronix/jopher"
	"github.com/oneiro-ndev/ndaumath/pkg/address"
	"github.com/oneiro-ndev/ndaumath/pkg/key"
)

// Key is the JS object associated with a Key (either public or private; the key itself knows)
// The representation here is the base58 string for the key.
// All functions return Promises and can fail.
type Key struct {
	*js.Object
	Key           string                          `js:"key"`
	Public        func(...interface{}) *js.Object `js:"Public"`
	Child         func(...interface{}) *js.Object `js:"Child"`
	HardenedChild func(...interface{}) *js.Object `js:"HardenedChild"`
	Sign          func(...interface{}) *js.Object `js:"Sign"`
	Address       func(...interface{}) *js.Object `js:"Address"`
}

func (k *Key) build(s string) *js.Object {
	k.Key = s
	k.Public = jopher.Promisify(k.public)
	k.Child = jopher.Promisify(k.child)
	k.HardenedChild = jopher.Promisify(k.hardenedChild)
	k.Sign = jopher.Promisify(k.sign)
	k.Address = jopher.Promisify(k.addr)
	return k.Object
}

// Address is the JS object associated with an address.
type Address struct {
	*js.Object
	Address string `js:"address"`
}

func (a *Address) build(addr string) *js.Object {
	a.Address = addr
	return a.Object
}

// Signature is generated by the Sign command
type Signature struct {
	*js.Object
	Signature string                          `js:"signature"`
	Verify    func(...interface{}) *js.Object `js:"Verify"`
}

func (s *Signature) build(sig string) *js.Object {
	s.Signature = sig
	s.Verify = jopher.Promisify(s.verify)
	return s.Object
}

func main() {
	js.Module.Get("exports").Set("NewPrivateMaster", jopher.Promisify(newPrivateMaster))

	// validate accepts an ndau address (like those returned by generate) and returns
	// a promise that is resolved with true, or rejected with false.
	// function validate(addr: string): Promise
	js.Module.Get("exports").Set("validate", jopher.Promisify(validateWrapper))

	// generate creates an address of the appropriate kind (which must be one of
	// 'a', 'n', 'e', or 'x') and uses data (which must be at least 32 bytes long
	// and should be a public ndau key) to generate a new ndau key returns a
	// Promise that resolves with the new key, or rejects with an error.
	// function generate(kind: string, data: string) : Promise
	js.Module.Get("exports").Set("generate", jopher.Promisify(generateWrapper))

	// wordsFromBytes gets a list of words that characterize an array of bytes;
	// first argument is a language code which for now must be 'en'
	// the contents of the resolved promise is an array of strings
	// function wordsFromBytes(lang: string, data: string) : Promise
	js.Module.Get("exports").Set("wordsFromBytes", jopher.Promisify(wordsFromBytes))

	// bytesFromWords retrieves a list of words that characterize an array of bytes;
	// first argument is a language code which for now must be 'en'
	// the contents of the resolved promise is a string containing the resulting bytes
	// function wordsFromBytes(lang: string, data: string) : Promise
	js.Module.Get("exports").Set("bytesFromWords", jopher.Promisify(bytesFromWords))
}

func newPrivateMaster(seed string) (*js.Object, error) {
	k := Key{Object: js.Global.Get("Object").New()}

	km, err := key.NewMaster([]byte(seed))
	if err != nil {
		return nil, err
	}
	kb, err := km.MarshalText()
	if err != nil {
		return nil, err
	}
	return k.build(string(kb)), nil
}

func (k *Key) public() (*js.Object, error) {
	ekey := new(key.ExtendedKey)
	err := ekey.UnmarshalText([]byte(k.Key))
	if err != nil {
		return nil, err
	}
	nk, err := ekey.Public()
	if err != nil {
		return nil, err
	}
	nb, err := nk.MarshalText()
	if err != nil {
		return nil, err
	}
	r := Key{Object: js.Global.Get("Object").New()}
	return r.build(string(nb)), nil
}

func (k *Key) child(n float64) (*js.Object, error) {
	ekey := new(key.ExtendedKey)
	err := ekey.UnmarshalText([]byte(k.Key))
	if err != nil {
		return nil, err
	}
	ndx := uint32(n)
	nk, err := ekey.Child(ndx)
	if err != nil {
		return nil, err
	}
	nb, err := nk.MarshalText()
	if err != nil {
		return nil, err
	}
	r := Key{Object: js.Global.Get("Object").New()}
	return r.build(string(nb)), nil
}

func (k *Key) hardenedChild(n float64) (*js.Object, error) {
	ekey := new(key.ExtendedKey)
	err := ekey.UnmarshalText([]byte(k.Key))
	if err != nil {
		return nil, err
	}
	ndx := uint32(key.HardenedKeyStart + n)
	nk, err := ekey.Child(ndx)
	if err != nil {
		return nil, err
	}
	nb, err := nk.MarshalText()
	if err != nil {
		return nil, err
	}
	r := Key{Object: js.Global.Get("Object").New()}
	return r.build(string(nb)), nil
}

func (k *Key) sign(msg string) (*js.Object, error) {
	ekey := new(key.ExtendedKey)
	err := ekey.UnmarshalText([]byte(k.Key))
	if err != nil {
		return nil, err
	}
	pk, err := ekey.ECPrivKey()
	if err != nil {
		return nil, err
	}
	b, err := hex.DecodeString(msg)
	if err != nil {
		return nil, err
	}
	sig, err := pk.Sign(b)
	if err != nil {
		return nil, err
	}
	r := Signature{Object: js.Global.Get("Object").New()}
	return r.build(b32.Encode(sig.Serialize())), nil
}

func (k *Key) addr() (*js.Object, error) {
	ekey := new(key.ExtendedKey)
	err := ekey.UnmarshalText([]byte(k.Key))
	if err != nil {
		return nil, err
	}

	a, err := address.Generate(address.KindUser, ekey.PubKeyBytes())
	if err != nil {
		return nil, err
	}

	r := Address{Object: js.Global.Get("Object").New()}
	return r.build(a.String()), nil
}

func (s *Signature) verify(msg, k string) (bool, error) {
	ekey := new(key.ExtendedKey)
	err := ekey.UnmarshalText([]byte(k))
	if err != nil {
		return false, err
	}
	pk, err := ekey.ECPubKey()
	if err != nil {
		return false, err
	}

	dsig, err := b32.Decode(s.Signature)
	if err != nil {
		return false, err
	}

	sig, err := btcec.ParseDERSignature(dsig, btcec.S256())
	if err != nil {
		return false, err
	}

	b, err := hex.DecodeString(msg)
	if err != nil {
		return false, err
	}

	if !sig.Verify(b, pk) {
		return false, errors.New("signature not verified")
	}

	return true, nil
}

func validateWrapper(addr string) (bool, error) {
	_, err := address.Validate(addr)
	return (err == nil), err
}

func generateWrapper(kind string, data string) (string, error) {
	k, err := address.NewKind(kind)
	if err != nil {
		return "", err
	}
	a, err := address.Generate(k, []byte(data))
	return a.String(), err
}

func wordsFromBytes(lang, b string) ([]string, error) {
	return WordsFromBytes(lang, []byte(b))
}

func bytesFromWords(lang string, w []interface{}) (string, error) {
	s := make([]string, len(w))
	for i, word := range w {
		s[i] = word.(string)
	}
	b, err := BytesFromWords(lang, s)
	if err != nil {
		return "", err
	}
	return string(b), nil
}
